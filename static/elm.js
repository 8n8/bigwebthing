const websocket = new WebSocket("ws://localhost:17448/websocket");
let websocketOpen = false;
websocket.addEventListener("open", (_) => (websocketOpen = true));

const app = Elm.Main.init({
  node: document.getElementById("elm"),
  flags: window.innerWidth,
});

const toElm = app.ports.jsToElm.send;

websocket.addEventListener("message", (event) => {
  toElm({key: "fromBackend", value: event.data});
});

const handlers = {
  toBackend: toBackend,
  runWasm: runWasm,
  rerunWasm: rerunWasm,
};

app.ports.elmToJs.subscribe(function ({ key, value }) {
  handlers[key](value);
});

function toBackend(str) {
  if (!websocketOpen) {
    toElm({ key: "noBackend", value: "" });
    return;
  }

  websocket.send(str);
}

// For interacting with the WASM generated by Rust. It just wraps
// up a slightly tidied-up version of the code generated by
// wasm-pack.
class Wasm {
  async init(codeBytes) {
    const module_ = await WebAssembly.compile(this.codeBytes);
    this.wasm = await WebAssembly.instantiate(module_, {});
    this.WASM_VECTOR_LEN = 0;
    this.mem8 = new Uint8Array(this.wasm.exports.memory.buffer);
    this.mem32 = new Int32Array(this.wasm.exports.memory.buffer);
  }

  _getMem8() {
    if (this.mem8 !== this.wasm.exports.memory.buffer) {
      this.mem8 = new Uint8Array(this.wasm.exports.memory.buffer);
    }
    return this.mem8;
  }

  _passStringToWasm(arg, malloc, realloc) {
    const cachedTextEncoder = new TextEncoder();
    if (realloc === undefined) {
      const buf = cachedTextEncoder.encode(arg);
      const ptr = malloc(buf.length);
      this._getMem8()
        .subarray(ptr, ptr + buf.length)
        .set(buf);
      this.WASM_VECTOR_LEN = buf.length;
      return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = this._getMem8();

    let offset = 0;

    for (; offset < len; offset++) {
      const code = arg.charCodeAt(offset);
      if (code > 0x7f) break;
      mem[ptr + offset] = code;
    }

    if (offset !== len) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }
      ptr = realloc(ptr, len, (len = offset + arg.length * 3));

      const view = this._getMem8().subarray(ptr + offset, ptr + len);
      const ret = cachedTextEncoder.encodeInto(arg, view);
      offset += ret.written ? ret.written : 0;
    }

    this.WASM_VECTOR_LEN = offset;
    return ptr;
  }

  _getMem32() {
    if (this.mem32.buffer !== this.wasm.exports.memory.buffer) {
      this.mem32 = new Int32Array(this.wasm.exports.memory.buffer);
    }
    return this.mem32;
  }

  _getArrayU8FromWasm0(ptr, len) {
    return this._getMem8().subarray(ptr / 1, ptr / 1 + len);
  }

  run(s) {
    const ptr0 = this._passStringToWasm(
      s,
      this.wasm.exports.__wbindgen_malloc,
      this.wasm.exports.__wbindgen_realloc
    );
    const len0 = this.WASM_VECTOR_LEN;
    this.wasm.exports.big_web_thing(8, ptr0, len0);
    const r0 = this._getMem32()[8 / 4 + 0];
    const r1 = this._getMem32()[8 / 4 + 1];
    const v1 = this._getArrayU8FromWasm0(r0, r1).slice();
    this.wasm.exports.__wbindgen_free(r0, r1 * 1);
    return v1;
  }
}

let WASM;
function runWasm({ userInput, wasmCode, msgId }) {
  WASM = new Wasm();
  WASM.init(base64js.toByteArray(wasmCode));
  try {
    const output = base64js.fromByteArray(WASM.run(userInput));
    toElm({ key: "wasmOutput", value: { id: msgId, wasm: output } });
  } catch (err) {
    toElm({key: "badWasm", value: err})
  }
}

function rerunWasm({ userInput, msgId }) {
  const output = base64js.fromByteArray(WASM.run(userInput));
  toElm({ key: "wasmOutput", value: { id: msgId, wasm: output } });
}
