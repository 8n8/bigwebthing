const app = Elm.Main.init({
  node: document.getElementById("elm"),
  flags: window.innerWidth,
});

const websocket = new WebSocket("ws://localhost:3001");
let websocketOpen = false;
websocket.addEventListener("open", (_) => (websocketOpen = true));

const handlers = {
  toWebsocket: toWebsocket,
  cacheGet: cacheGet,
  cacheSet: cacheSet,
  cacheDelete: cacheDelete,
  getPow: getPow,
  runWasm: runWasm,
  rerunWasm: rerunWasm,
};

app.ports.elmToJs.subscribe(function ({ key, value }) {
  handlers[key](value);
});

const toElm = app.ports.jsToElm.send;

let wasm;

// For interacting with the WASM generated by Rust. It just wraps
// up a slightly tidied-up version of the code generated by
// wasm-pack.
class Wasm {
  async init(codeBytes) {
    const module_ = await WebAssembly.compile(this.codeBytes);
    this.wasm = await WebAssembly.instantiate(module_, {});
    this.WASM_VECTOR_LEN = 0;
    this.mem8 = new Uint8Array(this.wasm.exports.memory.buffer);
    this.mem32 = new Int32Array(this.wasm.exports.memory.buffer);
  }

  _getMem8() {
    if (this.mem8 !== this.wasm.exports.memory.buffer) {
      this.mem8 = new Uint8Array(this.wasm.exports.memory.buffer);
    }
    return this.mem8;
  }

  _passStringToWasm(arg, malloc, realloc) {
    const cachedTextEncoder = new TextEncoder();
    if (realloc === undefined) {
      const buf = cachedTextEncoder.encode(arg);
      const ptr = malloc(buf.length);
      this._getMem8()
        .subarray(ptr, ptr + buf.length)
        .set(buf);
      this.WASM_VECTOR_LEN = buf.length;
      return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = this._getMem8();

    let offset = 0;

    for (; offset < len; offset++) {
      const code = arg.charCodeAt(offset);
      if (code > 0x7f) break;
      mem[ptr + offset] = code;
    }

    if (offset !== len) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }
      ptr = realloc(ptr, len, (len = offset + arg.length * 3));

      const view = this._getMem8().subarray(ptr + offset, ptr + len);
      const ret = cachedTextEncoder.encodeInto(arg, view);
      offset += ret.written ? ret.written : 0;
    }

    this.WASM_VECTOR_LEN = offset;
    return ptr;
  }

  _getMem32() {
    if (this.mem32.buffer !== this.wasm.exports.memory.buffer) {
      this.mem32 = new Int32Array(this.wasm.exports.memory.buffer);
    }
    return this.mem32;
  }

  _getArrayU8FromWasm0(ptr, len) {
    return this._getMem8().subarray(ptr / 1, ptr / 1 + len);
  }

  run(s) {
    const ptr0 = this._passStringToWasm(
      s,
      this.wasm.exports.__wbindgen_malloc,
      this.wasm.exports.__wbindgen_realloc
    );
    const len0 = this.WASM_VECTOR_LEN;
    this.wasm.exports.big_web_thing(8, ptr0, len0);
    const r0 = this._getMem32()[8 / 4 + 0];
    const r1 = this._getMem32()[8 / 4 + 1];
    const v1 = this._getArrayU8FromWasm0(r0, r1).slice();
    this.wasm.exports.__wbindgen_free(r0, r1 * 1);
    return v1;
  }
}

let WASM;
function runWasm({ userInput, wasmCode, msgId }) {
  WASM = new Wasm();
  WASM.init(base64js.toByteArray(wasmCode));
  const output = base64js.fromByteArray(WASM.run(userInput));
  toElm({ key: "wasmOutput", value: { id: msgId, wasm: output } });
}

function rerunWasm({ userInput, msgId }) {
  const output = base64js.fromByteArray(WASM.run(userInput));
  toElm({ key: "wasmOutput", value: { id: msgId, wasm: output } });
}

let RSA_KEY;
async function getRsaKey() {
  if (RSA_KEY !== undefined) {
    return [RSA_KEY, null];
  }
  try {
    const RSA_KEY = await localforage.getItem("rsaKey");
  } catch (err) {
    toElm({ key: "badCache", value: { key: "rsaKey", err: err } });
    return [null, "bad cache"];
  }
  if (RSA_KEY !== null) {
    return [RSA_KEY, null];
  }
  const RSA_KEY = await window.crypto.subtle.generateKey(
    {
      name: "RSA-OAEP",
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: "SHA-256",
    },
    false,
    ["encrypt", "decrypt"]
  );
  try {
    await localforage.setItem("rsaKey", RSA_KEY);
  } catch (err) {
    toElm({ key: "badCache", value: { key: "rsaKey", err: err } });
    return [null, "bad cache"];
  }
  return [RSA_KEY, null];
}

let ECDSA_KEY;
async function getEcdsaKey() {
  if (ECDSA_KEY !== undefined) {
    return [ECDSA_KEY, null];
  }
  try {
    const ECDSA_KEY = await localforage.getItem("ecdsaKey");
  } catch (err) {
    toElm({ key: "badCache", value: { key: "ecdsaKey", err: err } });
    return [null, "bad cache"];
  }
  if (ECDSA_KEY !== null) {
    return [ECDSA_KEY, null];
  }
  const ECDSA_KEY = await window.crypto.subtle.generateKey(
    { name: "ECDSA", namedCurve: "P-256" },
    false,
    ["sign", "verify"]
  );
  try {
    await localforage.setItem("ecdsaKey", ECDSA_KEY);
  } catch (err) {
    toElm({ key: "badCache", value: { key: "ecdsaKey", err: err } });
    return [null, "bad cache"];
  }
  return [ECDSA_KEY, null];
}

function isDifficult(hash, difficulty) {
  for (let i = 0; i < 32; i++) {
    if (hash[i] < difficulty) {
      return false;
    }
  }
  return true;
}

function proofOfWork(powInfo) {
  const buffer = new ArrayBuffer(8);
  const bufferView = new Uint8Array(buffer);
  const counter = new Int32Array(buffer);
  while (true) {
    const combined = combine(powInfo.unique, bufferView);
    const hash = nacl.hash(combined).slice(0, 32);
    if (isDifficult(hash, powInfo.difficulty)) {
      return combined;
    }
    counter[0] = counter[0] + 1;
  }
}

function getPow({ unique, difficulty }) {
  const pow = proofOfWork({
    unique: base64js.toByteArray(unique),
    difficulty: difficulty,
  });
  toElm({ key: "pow", value: base64js.fromByteArray(pow) });
}

async function cacheDelete(key) {
  try {
    await localforage.removeItem(key);
  } catch (err) {
    toElm({ key: "badCache", value: err });
  }
}

async function cacheSet({ key, value }) {
  try {
    await localforage.setItem(key, base64js.toByteArray(value));
  } catch (err) {
    console.log(err);
    toElm({ key: "badCache", value: { key: key, error: err } });
  }
}

async function cacheGet(key) {
  try {
    const value = await localforage.getItem(key);
    if (value !== null) {
      toElm({
        key: "fromCache",
        value: { key: key, value: base64js.fromByteArray(value) },
      });
      return;
    }
    toElm({ key: "nullCache", value: key });
  } catch (err) {
    toElm({ key: "badCache", value: { key: key, error: err } });
  }
}

function toWebsocket(bytes) {
  if (!websocketOpen) {
    toElm({ key: "badWebsocket", value: "" });
    return;
  }

  websocket.send(bytes);
}
