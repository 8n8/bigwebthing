title { `Specification of BigWebThing` }
author { `True Ghiassi` }
body {
`BigWebThing is a programming language, interpreter and tooling for creating and sharing programmable documents.`
tableofcontents
header 1 langSpec { `Language specification` }
header 2 types { `Types` }
`The interpreter checks the types for consistency before trying to run the program. A type is a set of values so, for example, 'i32' is the set of 32-bit integers.`
header 3 basicTypes { `Basic types` }
list {
{ `Integers.` }
{ `Floating point numbers.` }
{ `Unicode characters.` }
{ `Unicode strings.` }
{ `Tuple. Its length and the order of the elements are part of the type. The elements can be any mixture of types.` }
{ `List. All the elements are of the same type.` }
{ `Map. For key-value data. All the keys are one type and all the values are one type.` }
{ `Function. A has one input and one output.` }
{ `Set. An unordered collection of values of a particular type.` }
{ `Mutable variables and queues. These are used for communicating between threads safely.` }
{ `Atom. Any unused bit of the namespace, like "Red" (without quotes) or "tt" etc.` }
}
header 3 customTypes { `Custom types` }
`A custom type can be created by assigning a name to a set of values. A simple example is that a 'Bool' type could be defined as the set of the atoms 'True' and 'False'. Another example is a type that contains only the three integers 1, 2 and 3:`
code `syntax/customType`
`Custom types can mix basic types, as in this mix of atoms, integers, tuples and strings:`
code `syntax/mixedCustomType`
`Type sets are surrounded by curly brackets, and can be combined with the '+' symbol.`
header 3 interfaces { `Interfaces` }

`Generic functions can be created by using interfaces. An interface is a named set of function signatures. The interface name can then be used instead of a type, to makes types more general. So an interface name instead of a type means "Any type that has these functions implemented for it."`
p
`An interface has a name and a set of function signatures. Here is an example:`
code `syntax/interface`
`So the interface "smallPower" can be used as a type, and means 'all types that have functions "squared" and "cubed"', which in this case are f64 and i32. So the 'cubedSquared' function will work with both i32 and f64. Note that the variable 'a' in the interface declaration represents any type.`
header 2 pureFunction { `Functions` }
`There are three types of functions:`
list {
{ `Pure, referentially transparent functions, i.e. functions that can be replaced by their output value without affecting the program.` }
{ `Functions for changing mutable variables and queues in a thread-safe way.` }
{ `Functions for doing IO, for example reading from a file.` }
}
`This is a pure function called 'f' that squares a 32-bit integer integer:`
code `syntax/pureFunction`
`This is an IO function called 'g' that prints a string:`
code `syntax/ioFunction`
`This is a mutation function called 'h' that alters a mutable variable, multiplying it by six:`
code `syntax/mutationFunction`
`Rules:`
bullets {
{ `IO functions can only be used inside other IO functions.` }
{ `Mutation functions can be used inside IO functions and inside other mutation functions, but not in pure functions.` }
{ `Pure functions can be used anywhere` }
}
header 2 variables { `Variables` }
`Create a variable called 'x', with type string and value "hello":`
code `syntax/variable`
`The variable type can often be omitted and the interpreter will try to deduce it from the context.`
header 2 loops { `Loops` }
`There are no loops because data is immutable. The alternatives are fold, map or recursion.`
header 2 namespaces { `Namespaces` }
`A namespace is a piece of code that excludes all names defined outside it, unless they are explicitly imported. It also prevents its names being accessible from outside, unless they are explicitly exported. There is no limit to the number namespaces in a file, and they can be nested inside each other. The syntax is like this:`
code `syntax/namespace`
header 2 structs { `Structs` }
`A struct is a type that contains named fields. The syntax is as follows:`
code `syntax/struct`
`This code declares a struct called ` t `person` `, initiates a ` t `person` ` variable called ` t `p` `, and sets another variable ` t `n` ` to the value of the ` t `name` ` field of ` t `p` `.`
header 2 queuesVars { `Queues and mutable variables` }
`An example illustrates the syntax:`
code `syntax/queues`
`Evaluating function 'main' will result in '24' being printed. Queues are similar to mutable variables, except that they can take many values, with the first value put in to a queue being the last value to be taken out.`
header 2 separateIO { `Separation of pure and impure code` }
`There are two different ways of defining functions, one for those that do IO and another for doing pure computations. It is not possible to call IO functions from inside pure functions.`
header 2 concurrency { `Concurrency` }
`It is possible to run an IO function concurrently by prefixing it with the word 'go', like ` t `go nameOfFunction(arg)` `. The result of the function is ignored. Concurrent functions can communicate with each other with thread-safe queues and mutable variables. Queues and mutable variables are altered using Haskell-style Software Transactional Memory. This is done using special functions, declared with the 'dtm' keyword.`
header 2 case { `Case` }
code `syntax/case`
header 1 guilib { `GUI library` }
`The main purpose of the language is for creating programs with GUIs, so there is a built-in GUI library. The GUI is made up of elements that are positioned in a Cartesian plane. These elements are collected together in a list, with elements nearer the front being on top of elements nearer the end. The function for constructing the GUI has this type signature: ` code `syntax/viewSig` `It takes in the list of elements and generates the GUI. It also takes a queue to put the messages in when events such as mouse clicks on buttons happen.`
p
`Elements that can generate input, like buttons, are given functions for constructing messages. These messages, when generated by clicks etc, are put into the queue. Each element must also have a unique atom as a name, so it can be referred to for getting information about it; for example, getting the height of a paragraph.`
header 1 langInt { `Language interpreter` }
`It takes a program and builds a document from it. The program is a human-readable plain-text file. The steps that the interpreter takes are:`
list {
{ `Parse the file into an internal representation, failing if the syntax is wrong.` }
{ `Do a type-check on the internal representation, failing if the types don't match.` }
{ `Run the program.` }
}
header 2 parser { `Parser` }
header 3 parseNum { `Numbers` }
`There is more than one number type. The type is decided by the type annotation, not by the way the number is written. So a float does not have to have a decimal point.`
header 3 parseString { `Strings` }
`A string is delimited with either a single double quote or a triple double quote. In the first case, if a double quote is required inside the string then it must be preceded by a backslash, and a literal backslash is written as two backslashes. Strings separated by whitespace are automatically joined together.`
header 3 funcNames { `Function name rules` }
`It must:`
list {
{ `Only contain: a-z, A-Z, 0-9, and ` t `!Â£$&_?;'@#~` }
{ `Not be only numeric characters.` }
}
header 2 internalRep { `Internal representation of program` }
`A name to expression lookup map for storing expressions that have names. Each named expression is accompanied by its intended type, as specified in the source code. An expression can be any one of the following:`
bullets {
{ `Any value of the basic built-in types.` }
{ `A function. This is a list of the names of the input arguments and a name to expression map that uses those names. The expression named 'return' is evaluated first, so it is like the 'main' function of the program as a whole.` }
{ `An instruction to look up a named expression in the namespace and evaluate it. This includes a list of expressions to pass as arguments to the looked-up expression.` }
}
header 2 typeCheck { `Type checker` }
`It loops over the values in the internal representation of the named expressions in the program. For each one, it evaluates the type of the expression and compares it with the type specified in the source code. It raises an error if they do not match.`
p
`The function that evaluates the type of an expression needs these inputs:`
list {
{ `A namespace containing all the necessary named expressions.` }
{ `The expression to evaluate.` }
{ `The type of the expression to evaluate, as specified in the source code.` }
}
`The types of the various types of expression are calculated as follows:`
bullets {
{ `A basic built-in type will have its type decided by the parser.` }
{ `Functions. Recursively call the type check function on all the elements in the function's namespace.` }
{ `A name lookup and evaluation: Evaluate the types of the arguments, then look up the name in the namespace and read off the type, checking that the arguments are the correct types.` }
}
header 2 evaluation { `Program evaluation` }
`The program is evaluated by evaluating the 'main' function in the internal representation made by the parser. The evaluation function needs these inputs:`
list {
{ `A namespace containing all the necessary named expressions.` }
{ `The expression to evaluate.` }
args { `A list of expressions, which when evaluated will provide arguments to the expression.` }
}
`The various types of expression are evaluated as follows:`
bullets {
{ `A basic built-in type, or nothing, needs no evaluation.` }
{ `Functions: zip together the argument list (see ` ref args ` above) with the argument name list in the function definition and the function's own namespace. Then call the evaluation function recursively on the "return" expression in the namespace.` }
{ `For a name look-up, it first recursively evaluates the arguments. If the name is a built-in basic function, like '+', it just evaluates the expression directly. Otherwise, it looks up the name in the namespace and recursively calls the evaluate function on it.` }
}
header 1 tooling { `Tooling` }
`The main binary includes a text editor with syntax highlighting and Vim and Emacs modes.`
header 1 publicMsg { `Public messages` }
`Upload a message to a public HTTP server.`
header 1 httpServer { `HTTP server` }
`BWT can be run as an HTTP server.`
header 1 secretMsg { `Secret messages` }
`Send a secret message to another member.`
header 2 invite { `(Un)invite` }
`Invite someone to be a member, or revoke an existing invitation.`
header 2 search { `Search` }
`Ask someone else for information on a topic. This is done by sending some tags and a search string as JSON to the all the known contacts. These respond with what they know.`
header 1 editData { `Edit personal data` }
`Everyone keeps their own data, and can edit it as they wish.`
}
