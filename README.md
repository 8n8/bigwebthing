# Overview

BigWebThing is intended to provide a combined and improved solution to the problem of sharing messages and programs conveniently and securely.

User data is kept on their own machine, and never sent out unencrypted. Users' private crypto keys never leave their own machine.

Users can write programs and send them to each other safely and run them safely.

There is a message-passing server for sharing data between people.

The cost of running the server is met by users paying for the resources they use, as they use them.

It operates on a strict whitelist-only policy, so you only receive messages from people on your whitelist.

# Program structure

These are the different parts of the program:

1. (Go) The client backend. This runs on the client's computer and does most of the work, such as caching, crypto, and communicating with the server and the GUI.

2. (Elm) The GUI. This runs in a stripped-down web browser via webview.

3. (Javascript) The GUI plumbing. This handles the connection between the client backend and the Elm GUI, passing data through ports to Elm and websockets to the client backend.

4. (Rust / Webassembly) The user programs. These are programs that users can write and send to each other. They are pure functions written in Rust and compiled to Webassembly, and produce a DOM-like structure from a user input text box and user-uploaded binary blobs.

6. (Go) The server. This acts as a route between clients. They upload and download messages, and also use it to store their public keys.

# User ID displayed to the user

A user ID has two components:

1. The username generated by the server. This is a uint64, which is a unique ID in communications with the server. Since most usernames will not use most of the bits, it is displayed to the user as a variable-length integer at the end of their public-key fingerprint. The public-key fingerprint is a fixed length so it is clear which is which.

2. A fingerprint of the static public crypto key. This needs to be long enough so that it is infeasible to mount a man-in-the-middle attack. So if there is an adversary in control of the communication channel, in order to mount a man-in-the-middle, they need to find a pair of keys that matches the fingerprint for each party. If I use a very slow hash to generate the fingerprint, then a uint64 should be sufficient as a fingerprint.

So the whole user ID is:

	very_slow_hash(public_key || username)[:8] || (username without leading zeroes)

The encoding uses a custom word list with about 8000 words, very similar to Diceware. So for someone with a 3-byte username, their user ID will be 11 bytes, which will require 7 words, like:

basin glue tree unusable chug crushing hardwired

or

feminist polish fanfare front barber resume palpable

# Client backend API

The client backend provides a server on port 11833. It provides a static file server on /static, a websockets server, and an HTTP API. Websockets are useful for the client backend to push new messages to the front-end when they happen. HTTP is good because I can dump very large file uploads into the request bodies and stream them over to the backend. Elm does not have a native websockets capability, so it has to be done via a port. Everything that goes through an Elm port has to be a string in memory, so binary data has to be chunked and encoded to a string.

## Websockets API

Backend to frontend:

	Bad network connection
		1 byte: 0
	Good network connection
		1 byte: 1
    Message:
        1 byte: 2
        4 bytes: message ID
        sized string: commit hash
        sized string: subject
        sized string: main box
        sized string: blobs
        sized string: wasm
        sized string: members
    Whitelist:
        1 byte: 3
		sequence of username / fingerprint pairs:
            8 bytes: username
            8 bytes: fingerprint
    My user ID:
        1 byte: 4
        8 bytes: my username
        8 bytes: my fingerprint
    Backend ready
        1 byte: 5
    Message history
        1 byte: 6
        4 bytes: message ID
        string: output of git log
    Unique
        1 byte: 7
        4 bytes: unique
    Payments
        1 byte: 8
        sequence of payments, where a payment is
            8 bytes: Unix time of payment date
            4 bytes: amount paid in pence
    Price
        1 byte: 9
        4 bytes: price in pence
    Messages summary
        1 byte: 10
        sequence of message summaries, where a summary is
            4 bytes: message ID
            sized string: subject
            8 bytes: UNIX time of last edit
            membership, where a member is
                8 bytes: fingerprint
                8 bytes: username
    Membership status
        1 byte: 11
        either in free period
            1 byte: 0
            8 bytes: start time
        or lapsed due to missing payments
            1 byte: 1
        or paid up
            1 byte: 2


Frontend to backend:
    Set message:
        1 byte: 0
        4 bytes: message ID
        sized string: subject
        sized string: main box
        sized string: blobs
        sized string: wasm
        sized string: members
	Add to whitelist
		1 byte: 1
        8 bytes: username
        8 bytes: fingerprint
	Remove from whitelist
		1 byte: 2
		8 bytes: username
	Get message
		1 byte: 3
        4 bytes: message ID
	Get whitelist
		1 byte: 4
	Get my ID
		1 byte: 5
    Get history
        1 byte: 6
        4 bytes: message ID
    Revert
        1 byte: 7
        4 bytes: message ID
        20 bytes: commit hash to revert to
    Get commit
        1 byte: 8
        4 bytes: message ID
        20 bytes: commit hash to look at
    Get unique
        1 byte: 9
    Get payments
        1 byte: 10
    Get price
        1 byte: 11
    Get messages summary
        1 byte: 12
    Get membership
        1 byte: 13



## HTTP API

/setblob
	Request
		binary blob
	Response
		32 bytes: hash of blob
        4 bytes: size of blob
        sized string: file name of blob
        string: mime of blob
/getblob
	Request
        4 bytes: message ID
		32 bytes: hash of blob
	Response
		blob

# Server API

The server provides a TCP server on port 11453.

## Proof of work

Some APIs are protected by a proof of work problem. To create a proof of work token, the user must download some unique bytes and a difficulty value from the server, and find some more unique bytes that will create a 32-byte slow hash with all the bytes greater than the difficulty. The 'slow' hash should not be that slow. It should be slow enough that any implementation details apart from hashing are amortised. So a proof of work token is like this:

+ 16 bytes: unique from the server
+ 8 bytes: calculated by the client

The server checks that the first part is indeed something that it recently gave out, then that the hash of the whole meets the current difficulty.

## TCP API

It will accept incoming TCP connections. A connection begins unauthenticated, and can change to authenticated. Messages that are only sent/acceptable on an authenticated channel are marked "AUTH".

Each message should be not more than 16KB, and should be prefixed with a 2-byte Little-Endian length.

### Server to client

	New message from another user (AUTH)
		1 byte: 0
        8 bytes: sender username
        15991 bytes: the message
    New username (AUTH)
        1 byte: 1
        8 bytes: username
    Proof of work info
        1 byte: 2
		1 byte: difficulty
		16 bytes: random
    Price
        1 byte: 3
        4 bytes: monthly price in GBP^(-2)
    Public static key
        1 byte: 4
        8 bytes: key owner
        32 bytes: their key

### Client to server

    Get proof of work info
        1 byte: 0
    Sign in
        1 byte: 1
	    16 bytes: secret session key
	    8 bytes: username
    New account
		1 byte: 2
		24 bytes: proof of work
		16 bytes: random session key
        32 bytes: public static encryption key
	Send message (AUTH)
		1 byte: 3
		8 bytes: recipient username
		15991 bytes: message
	Delete message (AUTH)
		1 byte: 4
		32 bytes: message hash
	Get price (AUTH)
		1 byte: 5
    Add contact (AUTH)
        1 byte: 6
        8 bytes: contact username
    Remove contact (AUTH)
        1 byte: 7
        8 bytes: contact username
    Get public static key (AUTH)
        1 byte: 8
        8 bytes: their username

# Client to client

## API

A message is a tarred Git repository.

Then the message is sliced up into chunks, each chunk is encrypted, and is sent.

Before encryption, a chunk must be exactly 15942 bytes long. A chunk is encoded like this:

15942 bytes
    either the whole message fits in one chunk
        1 byte: 0
        2 bytes: the length of the message
        the message
        padding
    or this is a part of a sequence but not the last item
        1 byte: 1
        4 bytes: chunk counter, starting at 0
        4 bytes: total number of chunks in the sequence
        the chunk
    or this is the final message in a sequence
        1 byte: 2
        32 bytes: the hash of the whole message before chunking
        2 bytes: length of the chunk
        the chunk
        padding

## Crypto

The cryptography is done using Cacophony, a Noise implementation in Haskell. It uses the KK pattern. Each user has a pair of static keys. For each of their contacts they have a public static key, and some handshakes in various stages. Temporary keys deleted after one payload. The server will accept messages that are 15991 bytes long:

15991 bytes
    either some fresh first handshake messages
        1 byte: 0
        15984 bytes: 333 48-byte messages
            32 bytes: plain-text ephemeral key
            16 bytes: overhead of empty payload
        6 bytes: padding
    or some fresh second handshake messages
        1 byte: 1
        1 byte: number of messages
        the messages, 96 bytes each (max 166 will fit)
            32 bytes: initial ephemeral key
                used as the unique session reference
            16 + 32 bytes: encrypted ephemeral key
            16 bytes: overhead of empty payload
        padding
    or a transport message
        1 byte: 2
        32 bytes: initial ephemeral key
            used as the unique session reference
        15958 bytes: Noise transport message
            16 bytes: crypto overhead
            15942 bytes: plaintext

# Client cache

blobs/
    A flat folder of binaries, named by their hash.
messages/
    A flat folder of Git repositories, named by some unique ID. Each Git repository contains:
        subject.txt
        mainBox.txt
        blobs.txt
            The hashes and original file names of the blobs attached to the repository. Each line in the file is a 32-byte hash followed by a space, followed by a file name.
        wasm.txt
            Contains the 32-byte hash of the WASM code for this repository.
        members.txt
            The usernames of the members, one per line.
crypto
    A binary file containing all my keys, sessions, and other crypto information.
log
	A log of error messages, for debugging.

# Server cache

proofOfWorkDifficulty
	A file containing the proof of work difficulty.
price
	A file containing the price.
messages/
	A flat directory of messages, named by counter.
database
	message_counts
		sender username
        number of messages this month
    payments
        username
        timestamp
	users
		username
		hashed session key
        static key
    contacts
        owner username
        contact username
	tofrom
        counter (to keep messages in order)
		to username
		from username

# Pricing

There is a fixed monthly charge, paid in advance, but the first part of a month and full month is free. There is a generous usage allowance, that is intended to be high enough that non-abusive users will never reach it.
