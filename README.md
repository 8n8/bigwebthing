# Overview

BigWebThing is intended to provide a combined and improved solution to the problem of sharing messages and programs conveniently and securely.

User data is kept on their own machine, and never sent out unencrypted. Users' private crypto keys never leave their own machine.

Users can write programs and send them to each other safely and run them safely.

There is a message-passing server for sharing data between people.

The cost of running the server is met by users paying for the resources they use, as they use them.

It operates on a strict whitelist-only policy, so you only receive messages from people on your whitelist.

# Program structure

These are the different parts of the program:

1. (Go) The client backend. This runs on the client's computer and does most of the work, such as caching, crypto, and communicating with the server and the GUI.

2. (Elm) The GUI. This runs in a stripped-down web browser via webview.

3. (Javascript) The GUI plumbing. This handles the connection between the client backend and the Elm GUI, passing data through ports to Elm and websockets to the client backend.

4. (Rust / Webassembly) The user programs. These are programs that users can write and send to each other. They are pure functions written in Rust and compiled to Webassembly, and produce a DOM-like structure from a user input text box and user-uploaded binary blobs.

6. (Go) The server. This acts as a route between clients. They upload and download messages, and also use it to store their public keys.

# User ID

A user ID has two components:

1. A username generated by the server.  This is a variable-length unsigned integer, which is a unique ID in communications with the server. It will be at least one byte, with the first user having an ID of 0x00, the second 0x01, and so on.

2. A fingerprint of the static public crypto key. This needs to be long engough so that it is infeasible to mount a man in the middle attack. So if there is an adversary in control of the communication channel, in order to mount a man-in-the-middle, they need to find a pair of keys that matches the fingerprint for each party. If I use a very slow hash to generate the fingerprint, then a uint64 should be sufficient as a fingerprint. The fingerprint is generated by hashing the public key concatenated with the username from the server.

So the whole user ID is:

	very_slow_hash(public_key || username)[:8] || username

The encoding uses a custom word list with about 8000 words, very similar to Diceware. So for someone with a 3-byte username, their user ID will be 11 bytes, which will require 7 words, like:

basin glue tree unusable chug crushing hardwired

or

feminist polish fanfare front barber resume palpable

# Client backend API

The client backend provides a server on port 11833. It provides a static file server on /static, a websockets server, and an HTTP API. Websockets are useful for the client backend to push new messages to the front-end when they happen. HTTP is good because I can dump very large file uploads into the request bodies and stream them over to the backend. Elm does not have a native websockets capability, so it has to be done via a port. Everything that goes through an Elm port has to be a string in memory, so binary data has to be chunked and encoded to a string.

## Websockets API

Backend to frontend:

	Bad network connection
		1 byte: 0
	Good network connection
		1 byte: 1
	Send failed
		1 byte: 2
		4 bytes: message ID
	Progress of sending
		1 byte: 3
        4 bytes: message ID
		4 bytes: total bytes in message
		4 bytes: bytes sent
    Message:
        1 byte: 4
        4 bytes: message ID
        sized string: commit hash
        sized string: subject
        sized string: main box
        string: metadata
    Whitelist:
        1 byte: 5
		sequence of sized user IDs
    My ID
        1 byte: 6
        my ID
    Drafts summary
        1 byte: 7
        drafts summary
    Sent summary
        1 byte: 8
        sent summary
    Inbox summary
        1 byte: 9
        inbox summary
    Backend ready
        1 byte: 10
    Merge candidates
        1 byte: 11
        4 bytes: message ID
        list of 4-byte message IDs
    Message history
        1 byte: 12
        4 bytes: message ID
        string: output of git log
    Unique
        1 byte: 13
        4 bytes: unique

Frontend to backend:
    Set message:
        1 byte: 0
        4 bytes: message ID
        sized string: subject
        sized string: main box
        sized string: metadata
	Send message
		1 byte: 1
        4 bytes: message ID
        user ID of recipient
	Add to whitelist
		1 byte: 2
		user ID
	Remove from whitelist
		1 byte: 3
		user ID
	Get message
		1 byte: 4
        4 bytes: message ID
	Get whitelist
		1 byte: 5
	Get my ID
		1 byte: 6
	Get drafts summary
		1 byte: 7
	Get sent summary
		1 byte: 8
	Get inbox summary
		1 byte: 9
    Get merge candidates
        1 byte: 10
        4 bytes: message ID
    Merge
        1 byte: 11
        4 bytes: message ID to merge into
        4 bytes: message ID to merge from
    Get history
        1 byte: 12
        4 bytes: message ID
    Revert
        1 byte: 13
        4 bytes: message ID
        string: commit hash to revert to
    Get commit
        1 byte: 14
        4 bytes: message ID
        string: commit hash to look at
    Get unique
        1 byte: 15

## HTTP API

/setblob
	Request
		binary blob
	Response
		32 bytes: hash of blob
        4 bytes: size of blob
        sized string: file name of blob
        string: mime of blob
/getblob
	Request
		1 byte: 4
        4 bytes: message ID
		32 bytes: hash of blob
	Response
		blob

# Server API

The server provides an HTTP API on port 8001, and also a TCP connection on 8002 so that the server can send new messages to the client without them being requested first.

## Proof of work

Some APIs are protected by a proof of work problem. To create a proof of work token, the user must download some unique bytes and a difficulty value from the server, and find some more unique bytes that will create a slow hash with all the bytes greater than the difficulty.  So a proof of work token is like this:

+ 16 bytes: unique from the server
+ 8 bytes: calculated by the client

The server checks that the first part is indeed something that it recently gave out, then that the hash of the whole meets the current difficulty.

## Username encoding

A username is a variable-length integer, at least one byte long. It is encoded by prefixing it by a byte containing its length.

## TCP API

It will accept incoming TCP connections. The client's first message should be like this:

	sized username
	16 bytes: secret session key

Then the client should just listen on the connection, and use it to upload messages to the server. Each message should be not more than 16KB, and should start with a 2-byte Little-Endian length.

Server to client

	Request for an ephemeral key
		1 byte: 0
	New message from another user
		1 byte: 1
        32 bytes: my ephemeral public key
        96 bytes: handshake message
            32 bytes: sender ephemeral public key
            48 bytes: sender encrypted static key
                32 bytes: sender static key
                16 bytes: authentication tag
            16 bytes: authentication tag for empty payload
        48 bytes: encrypted transport message
            32 bytes: blob ID
            16 bytes: authentication tag
    New username
        1 byte: 2
        username
    Proof of work info
        1 byte: 3
		1 byte: difficulty
		16 bytes: random
    Price
        1 byte: 4
        4 bytes: price in GBP^(-4)
    Ephemeral key
        1 byte: 5
        32 bytes: public ephemeral key
        username: owner of key
    No ephemeral key
        1 byte: 6
        username: potential owner of key
    Blob
        1 byte: 7
        32 bytes: blob ID
        blob

Client to server

	Create account
		1 byte: 0
		24 bytes: proof of work
		16 bytes: random session key
        32 bytes: static public key
	Get proof of work info
        1 byte: 1
	Send message
		1 byte: 2
		16 bytes: session key
		my username
		recipient username
		message
    Upload blob
        1 byte: 3
        16 bytes: session key
        sized bytes: my username
        32 bytes: blob ID (must be unique, so random is best)
        blob
	Download blob
		1 byte: 4
		16 bytes: session key
		my username
		32 bytes: blob ID
	Delete message
		1 byte: 5
		16 bytes: session key
		sized bytes: my username
		32 bytes: message hash
	Get price
		1 byte: 6 
	Get ephemeral key for user
		1 byte: 7
		24 bytes: proof of work
		their username
	Upload ephemeral key
		1 byte: 8
		16 bytes: session key
		sized bytes: my username
		32 bytes: the key
			
# Client to client

## API

A message is a tarred Git repository. 

Then the message is sliced up into 15KB chunks, each chunk is encrypted, and is sent.

Before encryption, a chunk must be exactly 15KB long. A chunk is encoded like this:

	sized padding
		2 bytes: length of padding
		the padding: it doesn't matter what it is, so just use zeros
	4 bytes: a counter, starting at 0
	4 bytes: the total number of chunks in the whole message
	32 bytes: the hash of the whole message before chunking
	all the rest of the bytes: the chunk

## Crypto

The end-to-end cryptography is done using Noise, using the KX pattern, i.e. the sender (the respondent) knows the receiver's (initiator) public static key in advance.

The KX handshake is:

-> s
...
-> e
<- e, ee, se, s, es

Any message payloads after this handshake are secure.

The server maintains a list of 100 ephemeral public keys for each user, and prompts them for new ones when they get used.

So to send someone a message, I download one of their ephemeral keys from the server, and use Noise to generate an encrypted ephemeral key to send to them.

Then I use Noise again to encrypt a payload. So I send them:

their ephemeral key || my encrypted ephemeral key || my encrypted static key || my transport message

Each user must keep a record of their valid, unused ephemeral keys, and never accept a message that reuses an ephemeral key.

When I receive a message, I need to:

1. get their static key from my cache
2. check that the ephemeral key they are offering (originally from me) has not been used
3. feed it all through Noise and get the plain-text, AND check their static key is in my contacts

If the plaintext is too long to fit into a Noise message, it is chunked up, and subsequent messages are sent using the same session. The session should be thrown away after the whole message has been sent, to preserver forward secrecy between messages.

# Client cache

messages/
    A flat folder of Git repositories, named by some unique ID. Each Git repository contains:
        subject.txt
        mainBox.txt
        metadata
        blobs/
            A flat folder of blobs, named by hash.
        program.wasm
database
	sent
		message ID
		time
		to
	received
		from
		message ID
		time
	fingerprints
		username
		fingerprint
	my_ephemeral_keys
		public
		secret
myKeys
	A binary file containing my private static key, session key, and username.
log
	A log of error messages, for debugging.
unique
    an 8-byte file containing an encoded uint64, used for making unique values, such message IDs

# Server cache

proofOfWorkDifficulty
	A file containing the proof of work difficulty.
price
	A file containing the price.
messages/
	a flat directory of messages, named by hash
database
	uploads
		sender username
		4 bytes: price
		8 bytes: Unix timestamp
		32 bytes: hash of message
	payments (obtained from payments provider API)
		username
		signed payment confirmation from provider
	users
		username
		hashed session key
	ephemeral_keys
		username
		key
	tofrom
		to username
		from username
		hash of message

# Pricing

There is a small fixed charge for each blob upload.

Blobs last for a few weeks and are then deleted automatically.

In its database, the server records blob uploads for each user, and payments by each user.  When someone uploads a new blob, the server queries these tables to calculate the user's balance. If the balance is high enough, the blob is accepted.
